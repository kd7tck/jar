# FANTASY CONSOLE VIRTUAL MACHINE SPEC SHEET VERSION 0.2.0

---

## Table of Contents

1.  Introduction
2.  Memory Layout
3.  Cartridge Format
4.  CPU Architecture
5.  Clock, Timing, and Synchronization
6.  Input System
7.  Audio System
8.  VRAM background Information
9.  Sprite System
10. Color Palette System
11. Text Rendering System
12. List Of Special Registers
13. Version History
14. Glossary of Terms
15. License

---

## 1. Version History
*   `v0.1.0 (Initial Draft)`: Document creation.
*   `v0.2.0 (In Progress)`: Structural improvements, clarifications, and additions. Converted to Markdown.
*   `v0.3.0 (In Progress)`: Added Hex and FPGA info, cleaned up.

---
## 2. Introduction

This document outlines the technical specifications for the FC-8 (Fantasy Console 8-bit), a virtual machine designed for creating and playing retro-style games. It details the hardware architecture, memory organization, graphics and audio systems, input mechanisms, and other essential features that define the FC-8 platform. This specification serves as a guide for developers wishing to create games, emulators, or development tools for the FC-8.

---
## 3. Memory Layout
Fixed Clock/Update Rate: `5MHZ`
Memory Range: `$0x00000` -> `$0xFFFFF` (1,048,576 Bytes)
Stack Range : `$0x00000` -> `$0x0FFFF` (64kb, Ascending Stack, starts at address 0)
VRAM background range : `$0x10000` -> `$0x1FFFF` (64kb or 256x256 with 256 possible colors)
Special Registers range : `$0x20000` -> `$0x2FFFF` (64kb or 256 clusters of 256 bytes)
Static Game Data AKA Cartridge : `$0x30000` -> `$0xFFFFF` (832KB, Program Code / Machine Code)

### System State on Reset/Power-On
Upon system reset or power-on, hardware components and CPU registers are initialized to defined states:
*   **CPU Registers:**
    *   Program Counter (PC): Set to the 'Program Entry Point' specified in the Cartridge Header (e.g., `$30100`). If no valid cartridge is found, the PC's state may be undefined or set to a default halt address (e.g., jump to self).
    *   Stack Pointer (SP): Initialized to `$00000`. (The stack is ascending, starts at memory location `$0x00000`. PUSH operations write data then increment SP. POP operations decrement SP then read data).
    *   Accumulator (A), Index X (X), Index Y (Y): Initialized to `$00`.
    *   Flag Register (F): Initialized to `$00`. (Note: some CPUs set Z flag if A is $00, this spec assumes F is entirely $00).
*   **Selected Special Function Registers (SFRs):** Refer to individual component sections for full default states. Key examples:
    *   `SCREEN_CTRL_REG` (`$0x20800`): `$00` (Display Disabled, 256x240 Mode).
    *   `AUDIO_SYSTEM_CTRL_REG` (`$0x207F1`): `$01` (Audio System Enabled).
    *   `AUDIO_MASTER_VOL_REG` (`$0x207F0`): `$07` (Max volume).
    *   Audio Channel Registers (e.g. `$0x20700`-`$0x20713`): All frequencies zero, volumes zero, channels disabled (control register bit 7 set to 0, or trigger bit 0 to 0).
    *   `PALETTE_ADDR_REG` (`$0x20810`): `$00`.
    *   VRAM Control Registers (`$0x20100` - `$0x20102` for `VRAM_FLAGS_REG`, `VRAM_SCROLL_X_REG`, `VRAM_SCROLL_Y_REG`): `$00`.
    *   `TEXT_CTRL_REG` (`$0x20840`): `$00` (Text Layer Disabled, Priority 0).
*   **Memory Contents:**
    *   Stack RAM (`$0x00000-$0x0FFFF`): Content is undefined on power-on.
    *   VRAM (`$0x10000-$0x1FFFF`): Content is undefined on power-on. Usually cleared to color index `$00` (transparent/black) by system boot/game code.
    *   Palette Data: Initialized to a default system palette (see Section 11).
    *   Text Character Map (`$0x21000-$0x2177F`): Content is undefined. Usually cleared by system boot/game code.

It is the responsibility of the bootloader (if present) or the game program to perform further initialization as needed (e.g., clearing VRAM, setting up character maps, configuring sound channels).

---
## 4. Cartridge Format

The FC-8 system loads game data from a cartridge image mapped into the upper portion of the CPU's address space. This section details the structure of that cartridge data.

### Cartridge Memory Region
As defined in the **Memory Layout** section, the cartridge data resides in the memory range `$0x30000` to `$0xFFFFF`. This provides 832KB for game data, which includes a header, program code, graphics, sound, and other assets.

### Cartridge Header
The first 256 bytes of the cartridge data (from `$0x30000` to `$0x300FF`) are dedicated to a header. This header provides metadata about the game and pointers to the various data sections within the cartridge. All offsets are relative to the start of the cartridge data area (`$0x30000`). Endianness for multi-byte fields (like offsets and sizes) is Little Endian, consistent with the CPU architecture.

#### Header Fields:
*   `$0x30000 - $0x30003 (4 bytes)`: **Magic Number**
    - ASCII characters "FC8C" (Fantasy Console 8-bit Cartridge). Used by the VM to validate the cartridge.
*   `$0x30004 - $0x30023 (32 bytes)`: **Game Title**
    - Null-terminated ASCII string representing the game's title. Max 31 characters + null.
*   `$0x30024 - $0x30025 (2 bytes)`: **Game Version**
    - Byte 0 (`$30024`): Major version.
    - Byte 1 (`$30025`): Minor version.
*   `$0x30026 - $0x30027 (2 bytes)`: **Program Entry Point**
    - A 16-bit absolute memory address (within the cartridge space, e.g., `$0x30100`) where program execution begins after the cartridge is loaded and validated.
*   `$0x30028 - $0x30029 (2 bytes)`: **Offset to Program Code**
    - 16-bit unsigned value. Offset from `$0x30000` to the start of the Program Code section. Typically `$0x0100` (i.e., immediately after the header).
*   `$0x3002A - $0x3002B (2 bytes)`: **Size of Program Code**
    - 16-bit unsigned value. Size of the Program Code section in bytes.
*   `$0x3002C - $0x3002D (2 bytes)`: **Offset to Sprite Data**
    - 16-bit unsigned value. Offset from `$0x30000` to the start of the Sprite Data section.
*   `$0x3002E - $0x3002F (2 bytes)`: **Size of Sprite Data**
    - 16-bit unsigned value. Size of the Sprite Data section in bytes.
*   `$0x30030 - $0x30031 (2 bytes)`: **Offset to Sound/Music Data**
    - 16-bit unsigned value. Offset from `$0x30000` to the start of the Sound/Music Data section.
*   `$0x30032 - $0x30033 (2 bytes)`: **Size of Sound/Music Data**
    - 16-bit unsigned value. Size of the Sound/Music Data section in bytes.
*   `$0x30034 - $0x30035 (2 bytes)`: **Offset to Map Data**
    - 16-bit unsigned value. Offset from `$0x30000` to the start of the Map Data section.
*   `$0x30036 - $0x30037 (2 bytes)`: **Size of Map Data**
    - 16-bit unsigned value. Size of the Map Data section in bytes.
*   `$0x30038 - $0x300FF (200 bytes)`: **Reserved**
    - Reserved for future expansion or developer-specific information (e.g., publisher ID, checksums). Should be initialized to zeros.

#### Data Sections:
The cartridge header points to several key data sections which follow it. The exact layout and order of these sections (after the header) can be flexible as long as the header accurately reflects their offsets and sizes.
*   **Program Code:**
    Contains the FC-8 machine code instructions that form the game's logic. The CPU begins execution at the 'Program Entry Point' specified in the header, which should be an address within this section.
*   **Sprite Data:**
    Contains the raw pixel data for all unique sprite patterns used by the game, as defined in the 'Sprite System' section (typically 16x16 pixels, 8-bit color depth, 256 bytes per sprite). The game code uses the 'Sprite ID' in the Sprite Attribute Table to reference these patterns.
*   **Sound/Music Data:**
    Stores data for in-game audio. This can include parameters for the sound chip's waveform generators, sequences for a music tracker, definitions for sound effects, or even simple PCM samples if the audio system and game code support it.
*   **Map Data:**
    Contains data used to define tilemaps, level layouts, or other large background structures for display in VRAM. This data is typically read by the game code and transferred to VRAM as needed.

#### Loading Process (Conceptual):
1.  On system power-on or reset with a cartridge present, the Fantasy Console VM first attempts to read the cartridge header starting at address `$0x30000`.
2.  It validates the 'Magic Number' ("FC8C"). If incorrect, the cartridge is considered invalid, and an error is typically displayed.
3.  If valid, the VM uses the 'Program Entry Point' from the header to set the Program Counter (PC) and begin execution of the game code.
4.  The running game code is then responsible for interpreting the other header fields (offsets and sizes for various data sections) to load and access its assets (sprites, sound, maps, etc.) from the cartridge memory region as required.

---
## 5. CPU Architecture
### Overall Design:
*   **CPU Name:** FC-8 (Fantasy Console 8-bit)
*   **Type:** 8-bit processor
*   **Endianness:** Little Endian

### Registers:
*   **Program Counter (PC):** 16-bit, points to the memory address of the next instruction to be fetched.
*   **Stack Pointer (SP):** 16-bit. The stack is ascending, meaning it grows towards higher memory addresses. It operates within the Stack Range `$0x00000` - `$0x0FFFF`.
    *   **Initialization:** SP is initialized to `$00000` on system reset.
    *   **PUSH operation:** When pushing an 8-bit value, the CPU first writes the value to the memory location pointed to by SP, and then SP is incremented by 1. When pushing a 16-bit value (like the Program Counter during JSR), the CPU writes the high byte to SP, increments SP, writes the low byte to the new SP, and then increments SP again (or a similar sequence ensuring low byte at lower address, high byte at higher address, and SP ends up +2). For FC-8, we'll define PUSH of a 16-bit value (PC) as:
        1. Write PCH (high byte of PC) to address SP.
        2. Increment SP.
        3. Write PCL (low byte of PC) to address SP.
        4. Increment SP.
        This means SP points to the next available empty slot after a push. (This contradicts the reset state note: "PUSH operations write data then increment SP". If SP points to last item, PUSH should be: store at SP, then inc. If SP points to next free, PUSH is: store at SP, then inc. Let's stick to: SP points to *next free slot*. So, PUSH writes to SP, then SP increments. POP decrements SP, then reads from SP. This aligns with SP starting at $00000 and being the *next available* slot.)
    *   **Revised PUSH for clarity based on 'points to next free slot' interpretation:**
        *   **8-bit PUSH (e.g., PHA):** The value is written to the memory location pointed to by SP. SP is then incremented by 1.
        *   **16-bit PUSH (JSR):** The high byte of the address (PCH) is written to memory at SP. SP is incremented. Then the low byte (PCL) is written to memory at the new SP. SP is incremented again. (Order: PUSH PCH, then PUSH PCL, stack grows upwards with PCL at SP-1 and PCH at SP-2 after the operation, SP points to next free slot).
    *   **Revised POP for clarity based on 'points to next free slot' interpretation:**
        *   **8-bit POP (e.g., PLA):** SP is decremented by 1. The value is then read from the memory location pointed to by the new SP.
        *   **16-bit POP (RTS):** SP is decremented. The low byte of the address (PCL) is read from memory at SP. SP is decremented again. The high byte (PCH) is read from memory at the new SP. (Order: POP PCL, then POP PCH).
    *   This implies SP always points to the next free/available memory location on the stack. An empty stack has SP = `$00000`.
*   **Accumulator (A):** 8-bit, used for arithmetic, logical, and data transfer operations.
*   **Index Register X (X):** 8-bit, primarily used for indexed addressing modes.
*   **Index Register Y (Y):** 8-bit, primarily used for indexed addressing modes.
*   **Flag Register (F):** 8-bit, contains status flags that reflect the result of operations.
    *   Bit 7: **N (Negative)** - Set if the result of an operation is negative (MSB is 1).
    *   Bit 6: **V (Overflow)** - Set if an arithmetic operation resulted in an overflow.
    *   Bit 5: - (Unused)
    *   Bit 4: - (Unused)
    *   Bit 3: - (Unused)
    *   Bit 2: - (Unused)
    *   Bit 1: **Z (Zero)** - Set if the result of an operation is zero.
    *   Bit 0: **C (Carry)** - Set if an operation generated a carry or borrow.

### Instruction Set Architecture (ISA):
Instructions are generally 1 to 3 bytes long, consisting of an opcode and optional operands (data or memory addresses).

### CPU Implementation Notes for FPGA
Implementing the FC-8 CPU on an FPGA involves translating the architectural specifications into a hardware description (using Verilog or VHDL, for example). Each instruction in the ISA would typically be implemented as a state machine within the FPGA. The CPU's overall operation revolves around the fetch-decode-execute cycle, driven by the 5MHz system clock. Memory access (to stack, VRAM, special registers, or cartridge ROM) will need to adhere to the timing capabilities of the chosen FPGA memory resources (e.g., BRAM access times).

#### Opcode Table (Partial):
| Mnemonic      | Hex Opcode | Bytes | Addressing Mode(s)        | Flags Affected | Description                                       |
|---------------|------------|-------|---------------------------|----------------|---------------------------------------------------|
| LDA #`$value` | `$A9`      | 2     | Immediate                 | N, Z           | Load Accumulator with immediate value.            |
| LDA `$addr`   | `$AD`      | 3     | Absolute                  | N, Z           | Load Accumulator from absolute address.           |
| LDA `$zp`     | `$A5`      | 2     | Zero-Page                 | N, Z           | Load Accumulator from zero-page address.          |
| STA `$addr`   | `$8D`      | 3     | Absolute                  |                | Store Accumulator to absolute address.            |
| STA `$zp`     | `$85`      | 2     | Zero-Page                 |                | Store Accumulator to zero-page address.           |
| ADC #`$value` | `$69`      | 2     | Immediate                 | N, V, Z, C     | Add with Carry to Accumulator.                    |
| SBC #`$value` | `$E9`      | 2     | Immediate                 | N, V, Z, C     | Subtract with Carry from Accumulator.             |
| INC `$addr`   | `$EE`      | 3     | Absolute                  | N, Z           | Increment value at memory location.               |
| INC `$zp`     | `$E6`      | 2     | Zero-Page                 | N, Z           | Increment value at zero-page memory location.     |
| DEC `$addr`   | `$CE`      | 3     | Absolute                  | N, Z           | Decrement value at memory location.               |
| DEC `$zp`     | `$C6`      | 2     | Zero-Page                 | N, Z           | Decrement value at zero-page memory location.     |
| JMP `$addr`   | `$4C`      | 3     | Absolute                  |                | Jump to absolute address.                         |
| JSR `$addr`   | `$20`      | 3     | Absolute                  |                | Jump to Subroutine. Pushes the address of the last byte of the JSR instruction (PC+2 for a 3-byte JSR, effectively ReturnAddress-1) onto the stack, then sets PC to the operand address. SP is incremented by 2. |
| RTS           | `$60`      | 1     | Implied                   |                | Return from Subroutine. Pulls a 16-bit address (ReturnAddress-1) from the stack (PCL first, then PCH, SP is decremented by 2 in total). Sets PC to (pulled_address + 1).|
| PHA           | `$48`      | 1     | Implied                   |                | Push Accumulator onto Stack.                      |
| PLA           | `$68`      | 1     | Implied                   | N, Z           | Pull Accumulator from Stack.                      |
| BNE `$offset` | `$D0`      | 2     | Relative                  |                | Branch if Zero flag is clear.                     |
| BEQ `$offset` | `$F0`      | 2     | Relative                  |                | Branch if Zero flag is set.                       |
| BCS `$offset` | `$B0`      | 2     | Relative                  |                | Branch if Carry flag is set.                      |
| BCC `$offset` | `$90`      | 2     | Relative                  |                | Branch if Carry flag is clear.                      |
| CMP #`$value` | `$C9`      | 2     | Immediate                 | N, Z, C        | Compare Accumulator with immediate value.         |
| AND #`$value` | `$29`      | 2     | Immediate                 | N, Z           | Logical AND Accumulator with immediate value.     |
| ORA #`$value` | `$09`      | 2     | Immediate                 | N, Z           | Logical OR Accumulator with immediate value.      |
| EOR #`$value` | `$49`      | 2     | Immediate                 | N, Z           | Logical XOR Accumulator with immediate value.     |
| NOP           | `$EA`      | 1     | Implied                   |                | No Operation.                                     |
| HLT           | `$02`      | 1     | Implied                   |                | Halt Processor (e.g., by jumping to self `$02` -> JMP `$0002`). |

### Instruction Cycle Counts
The following table provides estimated cycle counts for each instruction. These are typical values for a simple 8-bit CPU design on an FPGA. Actual cycle counts can vary based on the specifics of the FPGA implementation, memory access speeds, and whether page boundaries are crossed by indexed addressing modes. These counts assume that the opcode and any immediate operands have already been fetched.

| Mnemonic        | Addressing Mode(s)          | Estimated Cycles        |
|-----------------|-----------------------------|-------------------------|
| LDA             | Immediate                   | 2 cycles                |
| LDA             | Zero-Page                   | 3 cycles                |
| LDA             | Absolute                    | 4 cycles                |
| STA             | Zero-Page                   | 3 cycles                |
| STA             | Absolute                    | 4 cycles                |
| ADC             | Immediate                   | 2 cycles                |
| SBC             | Immediate                   | 2 cycles                |
| INC             | Zero-Page                   | 5 cycles (read-modify-write) |
| INC             | Absolute                    | 6 cycles (read-modify-write) |
| DEC             | Zero-Page                   | 5 cycles                |
| DEC             | Absolute                    | 6 cycles                |
| JMP             | Absolute                    | 3 cycles                |
| JSR             | Absolute                    | 6 cycles (includes stack push) |
| RTS             | Implied                     | 6 cycles (includes stack pull) |
| PHA             | Implied                     | 3 cycles (includes stack push) |
| PLA             | Implied                     | 4 cycles (includes stack pull) |
| BNE/BEQ/BCS/BCC | Relative (branch taken)     | 3 cycles                |
| BNE/BEQ/BCS/BCC | Relative (branch not taken) | 2 cycles                |
| CMP             | Immediate                   | 2 cycles                |
| AND/ORA/EOR     | Immediate                   | 2 cycles                |
| NOP             | Implied                     | 2 cycles                |
| HLT             | Implied                     | effectively infinite (or until reset) |

Note: For indexed addressing modes (e.g., `LDA $1000,X`), add 1 cycle if a page boundary is crossed when adding the index register to the base address. Operations that modify memory (INC, DEC, STA) typically require more cycles than read-only operations.

#### Addressing Modes:
*   **Immediate:** The operand is the actual data value. (e.g., `LDA #$A5` - Load `$A5` into A)
*   **Absolute:** The operand is a full 16-bit memory address. (e.g., `LDA $1234` - Load contents of memory location `$1234` into A)
*   **Zero-Page:** An optimized version of Absolute addressing for the first 256 bytes of memory (`$0000` - `$00FF`). The instruction uses only an 8-bit address, saving a byte and execution time. (e.g., `LDA $34` - Load contents of `$0034` into A)
*   **Indexed (Absolute,X / Absolute,Y / Zero-Page,X / Zero-Page,Y):** An offset from an index register (X or Y) is added to a base address to get the final memory address. (e.g., `LDA $1000,X` - If X contains `$10`, load contents of `$1010` into A)
*   **Indirect:** The instruction operand provides a 16-bit memory address which points to another 16-bit memory address where the actual data or target address is located. (e.g., `JMP ($FFFC)` - Read the 16-bit address stored at `$FFFC` and `$FFFD`, then jump to that address).
*   **Relative (for branches):** The operand is an 8-bit signed offset. This offset is added to the Program Counter (PC) to determine the target address of the branch. Used by conditional branch instructions (e.g., BNE, BEQ). The offset allows branching typically -128 to +127 bytes from the instruction *after* the branch.

#### Execution Cycle:
The FC-8 CPU follows a standard fetch-decode-execute cycle:
1.  **Fetch:** The CPU fetches the next instruction from the memory location pointed to by the Program Counter (PC). The PC is then incremented.
2.  **Decode:** The CPU decodes the fetched instruction to determine the operation to be performed and any operands involved. This includes identifying the addressing mode.
3.  **Execute:** The CPU performs the specified operation. This might involve reading from or writing to memory, performing arithmetic or logical operations in the ALU, or modifying the PC for jumps and branches. This cycle repeats for each instruction.

---
## 6. Clock, Timing, and Synchronization

This section details the system's timing characteristics and how game programs can synchronize with the hardware.

### CPU Clock:
The FC-8 CPU operates at a fixed clock speed of `5MHz` (5,000,000 cycles per second), as noted in the **Memory Layout** section.
This clock speed determines the rate at which CPU instructions are processed. While many simple instructions might complete in a few cycles, more complex instructions or those involving memory access to slower regions (if applicable) could take multiple cycles.

### Frame Rate / Display Refresh Rate:
The FC-8 system targets a display refresh rate of 60 Hz (60 frames per second).
This means the screen content is redrawn 60 times every second.
With a `5MHz` CPU clock, this provides approximately 83,333 CPU cycles per frame (5,000,000 cycles/sec / 60 frames/sec). Game logic and rendering for a single frame must complete within this budget.

### Synchronization Mechanisms:
Proper synchronization is crucial for smooth animation and avoiding visual artifacts like screen tearing.

#### VBLANK (Vertical Blanking Interval):
Between each frame draw, there is a period called the Vertical Blanking Interval (VBLANK). During this time, the display hardware is not actively drawing to the screen, making it the safest time to update graphics memory (VRAM, sprite tables, color palettes, text map).
The system signals VBLANK status via a special register:
*   `$0x20850` - `VSYNC_STATUS_REG` (VSync Status Register) (Read-only):
    *   Bit 0: `IN_VBLANK` (Read-only): This bit is 1 when the system is currently in the VBLANK period. It is 0 during the active display period. Games can poll this bit to wait for VBLANK.
    *   Bit 1: `NEW_FRAME` (Read-only, clears on read): This bit is set to 1 by the hardware at the very start of the VBLANK period for each new frame. It is automatically cleared to 0 by the hardware as soon as `VSYNC_STATUS_REG` is read by the CPU. This provides a reliable way to detect the beginning of a new frame processing window.
It is highly recommended that game logic synchronizes graphics updates to the VBLANK period.

#### Frame Counter:
The system provides a 16-bit frame counter, accessible via:
*   `$0x20820` - `FRAME_COUNT_LO_REG` (Read-only)
*   `$0x20821` - `FRAME_COUNT_HI_REG` (Read-only)
This counter increments by one at the start of each VBLANK period (coinciding with the `NEW_FRAME` flag being set). It allows games to time events over longer periods or implement logic based on frame counts. The counter wraps from `$FFFF` to `$0000`.

#### Wait Operations:
The FC-8 hardware itself does not define a specific CPU `WAIT` instruction tied to VBLANK. For precise timing within a frame, or for simple delays, games typically implement their own delay loops by consuming CPU cycles. Synchronizing to VBLANK using the `VSYNC_STATUS_REG` is the primary method for frame-level timing.

### Random Number Generator (`RAND_NUM_REG`)
The FC-8 provides a simple pseudo-random number generator (PRNG) accessible via a special register.
*   **`$0x20830` - `RAND_NUM_REG` (Random Number Generator Register) (Read/Write)**
    *   **Reading:** Returns an 8-bit pseudo-random number. The exact algorithm for the PRNG is not strictly defined but should provide a reasonably uniform distribution of byte values. A common implementation is a Linear Feedback Shift Register (LFSR). The sequence will repeat eventually.
    *   **Writing:** Writing any value to this register (the value itself is typically ignored) re-seeds the PRNG. Seeding can help in producing different sequences of random numbers on subsequent game plays or by using an unpredictable seed source (like frame count or user input timing). If not seeded, the PRNG will typically start with a default seed value on system reset, producing the same sequence each time.

### Master Display Control (`SCREEN_CTRL_REG`)
The primary control over the display output, including its visibility and overall resolution mode, is managed by the `SCREEN_CTRL_REG` located at `$0x20800`.
*   **`$0x20800` - `SCREEN_CTRL_REG` (Screen Control Register) (R/W)**
    *   **Bit 0: Display Enable** (Read/Write)
        -   `0` = Disable display output. The screen will typically be blank or show a default border color. This can be used for screen-off effects or to save processing during full-screen transitions if VRAM updates are slow. (Default: 0 on cold boot, should be set to 1 by system initialization or game).
        -   `1` = Enable display output. The hardware will render the VRAM background, sprites, and text layer as configured. (Default: System should aim to set this to 1 after basic initialization).
    *   **Bit 1: Active Display Mode** (Read/Write)
        -   `0` = **256x240 Mode**: The visible display area is 256 pixels wide by 240 pixels high.
            -   VRAM Y-coordinates from 0 to 239 are typically mapped to the screen.
            -   Vertical scrolling (`VRAM_SCROLL_Y_REG`) will operate within this 240-line window relative to the 256-line VRAM.
            -   The `Screen Bounding Bottom` effect (`$0x20000 - $0x200FF`) offsets are relative to Y=239.
            -   The Text Layer (if screen resolution for text is 256x240) will map directly.
        -   `1` = **256x256 Mode**: The visible display area is 256 pixels wide by 256 pixels high.
            -   The full 256 lines of VRAM can be made visible.
            -   Vertical scrolling (`VRAM_SCROLL_Y_REG`) uses the full 256-line range.
            -   The `Screen Bounding Bottom` effect (`$0x20000 - $0x200FF`) offsets are relative to Y=255.
            -   The Text Layer (32x30 characters = 256x240 pixels) will still occupy the top 240 lines; the bottom 16 lines will be solely VRAM/sprites, or text rendering might be clipped/undefined there depending on hardware. (It's recommended that if text is used in 256x256 mode, it's understood to primarily use the top 256x240 area).
    *   **Bits 2-7: Reserved** (Read/Write)
        -   Must be written as 0 for future compatibility. Their read value is undefined.

On system reset, `SCREEN_CTRL_REG` typically defaults to `$00` (Display Disabled, 256x240 Mode). Bootloader or game initialization routines are responsible for enabling the display and selecting the desired mode.

### Game Loop Expectation:
A typical game loop on the FC-8 would follow this structure:
1.  Wait for VBLANK: Poll `VSYNC_STATUS_REG` until the `IN_VBLANK` bit is set or the `NEW_FRAME` flag indicates a new frame has begun.
2.  Process Input: Read button states from the input register(s).
3.  Update Game Logic: Update game state, character positions, scores, AI, etc., based on input and current state. This should be optimized to fit within the CPU cycle budget per frame.
4.  Prepare Graphics Data: Modify VRAM tilemaps, update sprite attribute table entries (positions, IDs, attributes), update the text character map, and change color palette entries as needed. These operations are safest during VBLANK.
5.  (During Active Display): The hardware automatically takes the data prepared in VRAM, sprite tables, text map, and palette to draw the screen. The CPU is free to continue processing for the next frame, or if all work is done, it can enter a low-power state or idle loop until the next VBLANK.
6.  Repeat: Jump back to step 1.

---
## 7. Input System
### Controller Type:
The primary input device is a standard 2-button digital gamepad.
Buttons:
*   D-Pad: Up, Down, Left, Right
*   Action Buttons: Button A, Button B
*   System Buttons: Start, Select

### Input Register:
The state of the gamepad buttons is mapped to a single 8-bit register located at memory address `$0x20600`.
This address is within the Special Registers range.

Register `$0x20600` - `GAMEPAD_STATE_REG` (Gamepad State Register):
*   Bit 0: Up (1 if pressed, 0 if not pressed)
*   Bit 1: Down (1 if pressed, 0 if not pressed)
*   Bit 2: Left (1 if pressed, 0 if not pressed)
*   Bit 3: Right (1 if pressed, 0 if not pressed)
*   Bit 4: Button A (1 if pressed, 0 if not pressed)
*   Bit 5: Button B (1 if pressed, 0 if not pressed)
*   Bit 6: Start (1 if pressed, 0 if not pressed)
*   Bit 7: Select (1 if pressed, 0 if not pressed)

### Reading Input:
Game programs can read the byte value from memory address `$0x20600` (`GAMEPAD_STATE_REG`) at any time to get the current state of all gamepad buttons.
It is common practice to read this register once per frame to poll for input.

---
## 8. VRAM background Information

The FC-8 features a versatile VRAM background layer, which functions as a 256x256 pixel direct-mapped bitmap. Each pixel is an 8-bit color index, referencing the global 256-color palette. This background layer can be scrolled, flipped, and mirrored to create various visual effects. It is stored in the VRAM Background Range: `$0x10000` - `$0x1FFFF` (64KB).

### VRAM Data Layout
The 64KB of VRAM maps directly to a 256x256 grid of pixels. The byte at `$0x10000` corresponds to the color index of the pixel at coordinate (0,0) of the background bitmap. The byte at `$0x10001` is pixel (1,0), and so on. The address for a pixel at `(x, y)` within the VRAM bitmap is calculated as: `Address = $0x10000 + (y * 256) + x`.

Color index `$00` in the VRAM data is treated as transparent, allowing any layers behind this VRAM (if any were defined, though typically it's the rearmost graphical layer) to show through. However, it's more common for sprites or the text layer to be rendered *over* the VRAM background.

### Scrolling
*   `VRAM_SCROLL_X_REG` (`$0x20101`): This 8-bit register controls the fine horizontal scroll position of the VRAM background. A value of 0 means no scroll. As the value increases, the background content shifts to the left on the screen. The visible screen acts as a window into the 256-pixel wide VRAM background. For example, if `VRAM_SCROLL_X_REG` is 10, the pixel column from VRAM address `x=10` will be displayed at screen column `x=0`.
*   `VRAM_SCROLL_Y_REG` (`$0x20102`): This 8-bit register controls the fine vertical scroll position. An increasing value shifts the background content upwards on the screen. For example, if `VRAM_SCROLL_Y_REG` is 20, the pixel row from VRAM address `y=20` will be displayed at screen row `y=0`.

When scrolling, pixel coordinates are effectively wrapped around the 256x256 VRAM space. For example, if `VRAM_SCROLL_X_REG` is 250, and the screen is 256 pixels wide, the rightmost 6 columns on screen will show pixels from VRAM columns 0-5.

### Flipping and Mirroring (Tiling Effects)
Refer to `VRAM_FLAGS_REG` (`$0x20100`).
*   Bit 0 (Mirror-X): When set, the VRAM content fetched for display is mirrored horizontally. This means if the hardware is trying to display the right half of the screen, it will instead display a mirrored version of the left half of the VRAM source. This can be used with scrolling to create an infinitely scrolling background from a smaller unique portion.
*   Bit 1 (Mirror-Y): Similar to Mirror-X, but applies vertically.
*   Bit 2 (Flip-X): When set, the entire source VRAM content (after scrolling, before mirroring) is flipped horizontally before being rendered. This is different from mirroring which typically applies to one half of the content based on the other.
*   Bit 3 (Flip-Y): Similar to Flip-X, but applies vertically.
*   Bits 4-7: Page Select / Coarse Y Offset: In the context of a direct bitmap VRAM, these bits can be interpreted as a coarse scroll or page selection mechanism, effectively adding `(value * 16)` to the base Y scroll coordinate *before* fine scrolling is applied. The 4-bit signed value (-8 to +7) means an offset of -128 to +112 lines in 16-line blocks. For instance, a value of 1 in these bits would start rendering from VRAM row 16, on top of any `VRAM_SCROLL_Y_REG` value. This allows quickly switching between different vertical 'pages' or large areas of the VRAM bitmap.

### Screen Bounding Bottom Effect (`$0x20000` - `$0x200FF`)
These 256 registers provide a per-column vertical offset for the *bottom edge* of where the VRAM background (and potentially other layers, depending on hardware implementation) is drawn, creating a deformable bottom boundary for the display area. Each register `$0x20000 + X` corresponds to screen column X (0-255).

The 8-bit value in each register specifies an *upward offset* from the normal bottom screen edge (e.g., Y=239 or Y=255 depending on `SCREEN_CTRL_REG`). A value of 0 means no offset for that column; the screen ends at its normal maximum Y. A value of 16 means for that specific X column, rendering stops 16 pixels *above* the normal bottom edge. A value of 255 would mean the screen ends at Y=0 for that column (or is effectively masked).

This allows for effects like wavy water surfaces, pseudo-3D horizons, or masking parts of the bottom screen on a per-column basis. Pixels 'below' this dynamic boundary for a given column are typically not rendered or are filled with a border/backdrop color (e.g., color 0 from the palette).

The visual data 'removed' by this effect is clipped; it does not cause the content above it to scroll or shift down.

### Interaction with Other Layers
*   The VRAM background is generally the rearmost graphical layer.
*   Sprites are typically rendered on top of the VRAM background. However, a sprite's 'Priority' attribute can cause it to be rendered behind the VRAM background (see Section 10: Sprite System, Byte 3: Attribute Flags, Bit 2: Priority). This means the VRAM background pixel will be drawn if it's not transparent (color index `$00`).
*   The Text Layer, if enabled and its character cells do not have a transparent background, is rendered on top of the VRAM background. If a text cell's background is transparent, the VRAM background will show through (See Section 12: Text Rendering System).

---
## 9. Audio System
### Overall Capabilities:
The FC-8 features a 4-channel sound system. Each channel is independent and can generate the following waveforms:
*   Square wave (with variable duty cycle)
*   Sawtooth wave
*   Triangle wave
*   Noise (white noise generator)
One channel (e.g., Channel 4) can potentially be used for simple PCM sample playback by rapidly changing its volume or waveform register, though this is CPU intensive and requires careful programming.

### Channel Registers:
Each of the 4 channels has a dedicated block of 5 memory-mapped registers within the Special Registers range.

#### Channel 1 Registers:
*   `$0x20700` - `CH1_FREQ_LO_REG`: Channel 1 Frequency Control, Low Byte (R/W)
*   `$0x20701` - `CH1_FREQ_HI_REG`: Channel 1 Frequency Control, High Byte (R/W)
    (16-bit value, determines pitch. A value of 0 typically means silence on the channel.)
*   `$0x20702` - `CH1_VOL_ENV_REG`: Channel 1 Volume & Envelope Control (R/W)
    (Bits 7-4: Volume (0-15), Bit 3: Envelope Enable (1=On, 0=Off), Bits 2-0: Envelope Parameters (Unused for now, could be attack/decay rate))
*   `$0x20703` - `CH1_WAVE_DUTY_REG`: Channel 1 Waveform Select & Square Duty Cycle (R/W)
    (Bits 7-6: Waveform Select: 00=Square, 01=Sawtooth, 10=Triangle, 11=Noise)
    (Bits 5-4 (Square Only): Duty Cycle: 00=12.5%, 01=25%, 10=50%, 11=75%)
    (Bits 3-0: Unused)
*   `$0x20704` - `CH1_CTRL_REG`: Channel 1 Control (R/W)
    (Bit 0: Note Trigger (1=Start/Retrigger Note, 0=No effect). Automatically resets to 0 after triggering.)
    (Bit 7: Channel Enable (1=On, 0=Off, overrides trigger for silence))

#### Channel 2 Registers (`$0x20705` - `$0x20709`):
*   `$0x20705` - `CH2_FREQ_LO_REG` (R/W)
*   `$0x20706` - `CH2_FREQ_HI_REG` (R/W)
*   `$0x20707` - `CH2_VOL_ENV_REG` (R/W)
*   `$0x20708` - `CH2_WAVE_DUTY_REG` (R/W)
*   `$0x20709` - `CH2_CTRL_REG` (R/W)
(Registers function identically to Channel 1's)

#### Channel 3 Registers (`$0x2070A` - `$0x2070E`):
*   `$0x2070A` - `CH3_FREQ_LO_REG` (R/W)
*   `$0x2070B` - `CH3_FREQ_HI_REG` (R/W)
*   `$0x2070C` - `CH3_VOL_ENV_REG` (R/W)
*   `$0x2070D` - `CH3_WAVE_DUTY_REG` (R/W)
*   `$0x2070E` - `CH3_CTRL_REG` (R/W)
(Registers function identically to Channel 1's)

#### Channel 4 Registers (`$0x2070F` - `$0x20713`):
*   `$0x2070F` - `CH4_FREQ_LO_REG` (R/W)
*   `$0x20710` - `CH4_FREQ_HI_REG` (R/W)
*   `$0x20711` - `CH4_VOL_ENV_REG` (R/W)
*   `$0x20712` - `CH4_WAVE_DUTY_REG` (R/W)
*   `$0x20713` - `CH4_CTRL_REG` (R/W)
(Registers function identically to Channel 1's. This channel is often a candidate for PCM playback if volume is modulated quickly.)

### Global Audio Control Registers:
These registers control the overall audio output.
*   `$0x207F0` - `AUDIO_MASTER_VOL_REG`: Master Volume Control (R/W)
    (Bits 2-0: Master Volume (0-7). Affects all channels.)
    (Bits 7-3: Unused)
*   `$0x207F1` - `AUDIO_SYSTEM_CTRL_REG`: Audio System Enable/Disable (R/W)
    (Bit 0: Audio System Enable (1=Enabled, 0=Disabled/Muted). Default is 1.)
    (Bits 7-1: Unused)

### Sound Generation:
To produce a sound on a channel:
1.  Set the desired waveform using the channel's `WAVE_DUTY` register (e.g. `CH1_WAVE_DUTY_REG`).
2.  Set the desired volume (and envelope settings, if used) using the channel's `VOL_ENV` register (e.g. `CH1_VOL_ENV_REG`).
3.  Write the low and high bytes for the desired pitch to the channel's `FREQ_LO` and `FREQ_HI` registers (e.g. `CH1_FREQ_LO_REG`, `CH1_FREQ_HI_REG`).
4.  Set the Note Trigger bit in the channel's `CTRL` register (e.g. `CH1_CTRL_REG`) to 1. This will start the sound. The bit will automatically reset.
To stop a sound:
*   Set the channel's volume to 0 via its `VOL_ENV` register.
*   Or, disable the channel using Bit 7 of its `CTRL` register.
*   Setting frequency to 0 can also effectively silence a channel if the hardware interprets it as such.
*   Disabling the entire audio system via `AUDIO_SYSTEM_CTRL_REG` will mute all sounds.

---
## 10. Sprite System

### Sprite Definition:
#### Dimensions:
*   Standard sprite size is 16x16 pixels.
*   Larger entities can be formed by software by combining multiple sprites.
#### Color Depth:
*   Sprites use an 8-bit index per pixel, referencing a global 256-color palette.
*   The VRAM background also uses this same global palette (see **Memory Layout** VRAM background range for "256 possible colors").
#### Pixel Data Format:
*   Each 16x16 sprite requires 256 bytes of data (16 pixels * 16 pixels * 1 byte/pixel).
*   Pixel data is stored row by row, with the first byte being the top-left pixel of the sprite.
#### Transparency:
*   Color index `$00` (the first color) in the global 256-color palette is treated as transparent. Pixels with this color index will not be drawn.

### Sprite Storage (in Cartridge):
Sprite pixel data is stored in the 'Static Game Data AKA Cartridge' memory region, which spans from `$0x30000` to `$0xFFFFF` (832KB).
#### Access Method:
*   Sprites are identified by a Sprite ID (an unsigned byte, 0-255, for use in Sprite Attribute Tables, see below).
*   The pixel data for a given Sprite ID is found at memory address: `$0x30000` + (Sprite ID * 256 bytes).
#### Maximum Unique Sprites:
*   The cartridge ROM can store up to 3328 unique 16x16 sprite patterns (832KB / 256 bytes per sprite).
*   Note: The hardware sprite list uses an 8-bit ID, so up to 256 unique patterns can be *selected* for display in any given frame from this larger pool.

### Sprite Rendering and Attributes (Hardware Sprites):
Sprite rendering is managed by a list of up to 256 "Sprite Attribute Entries" located in a dedicated block of Special Registers from `$0x20200` to `$0x205FF`. Each entry is 4 bytes.
The system processes these entries in order (entry 0 to entry 255) to draw sprites.

#### Sprite Entry Definition (4 bytes per entry):
*   **Byte 0: Sprite ID** (unsigned byte)
    - Selects which of the 256-byte sprite patterns from the Cartridge ROM to display.
    - A Sprite ID of `$FF` can be used to disable this sprite entry (it will not be drawn).
*   **Byte 1: X-Position** (unsigned byte)
    - The horizontal screen coordinate for the sprite's left edge. (0 = leftmost pixel column).
*   **Byte 2: Y-Position** (unsigned byte)
    - The vertical screen coordinate for the sprite's top edge. (0 = topmost pixel row).
    - A Y-position of 0 is valid. Values that would place the sprite entirely off-screen (e.g., Y >= 240 for a 16x16 sprite on a 256x240 screen, assuming 240 is the visible height) effectively hide the sprite.
*   **Byte 3: Attribute Flags** (unsigned byte)
    - Bit 0: Flip-X (0 = Normal, 1 = Flipped Horizontally)
    - Bit 1: Flip-Y (0 = Normal, 1 = Flipped Vertically)
    - Bit 2: Priority
        - 0 = Normal Priority: Sprite is drawn behind VRAM background pixels (if the VRAM pixel is not transparent and the sprite has normal priority). If the sprite has high priority, it's drawn in front of the VRAM background.
        - 1 = High Priority: Sprite is drawn in front of ALL VRAM background elements, regardless of background priority.
    - Bits 3-7: Reserved for future use (e.g., palette bank selection for advanced palette modes, blending options). Must be set to 0 for compatibility.

#### Screen Coordinates & Display:
*   The screen resolution is effectively 256 pixels wide. The vertical resolution is typically 240 pixels, but VRAM is 256x256, allowing for vertical scrolling.
*   (0,0) is the top-left corner of the display area.
*   X-coordinates range from 0 (left) to 255 (right).
*   Y-coordinates range from 0 (top) to 239 or 255 (bottom, depending on visible screen configuration).

#### Rendering Limitations:
*   **Maximum On-Screen Sprites:** While there are 256 sprite attribute entries, the hardware can typically draw up to 64 sprites (those with valid IDs and on-screen positions) simultaneously on the screen per frame. Entries beyond the first 64 *processed and visible* sprites might be ignored.
*   **Maximum Sprites Per Scanline:** The hardware can draw up to 8 sprites on any single horizontal scanline. If more than 8 sprites are positioned to overlap on the same scanline, sprites with lower entry numbers (earlier in the `$0x20200` list) take precedence.
*   **Clipping:** Sprites are automatically clipped at the screen edges. If a sprite's X/Y position causes it to be partially or wholly off-screen, only the visible portions are drawn.

### Interaction with VRAM Background:
Sprites are rendered onto the display along with the VRAM background.
The 'Priority' bit in the sprite's Attribute Flags (Byte 3, Bit 2) determines layering.
Generally, sprites are drawn "on top" of the VRAM background.
- If a sprite has **Normal Priority (0)**:
    - It is drawn *behind* any non-transparent VRAM background pixel at the same location.
    - It is drawn *in front* of transparent VRAM background pixels (color index `$00`).
- If a sprite has **High Priority (1)**:
    - It is drawn *in front* of all VRAM background pixels, regardless of whether the VRAM pixel is transparent or not.
Color index `$00` (transparent) in a sprite's pixel data always allows whatever is behind it (VRAM background or lower priority sprites) to show through.

---
## 11. Color Palette System

The FC-8 uses a global 256-color palette, shared by the VRAM background and sprites. Each color in the palette is defined using an 8-bit R3G3B2 format.

### Color Format (R3G3B2):
Each byte representing a color is formatted as follows:
*   Bits 7-5: Red component (3 bits, 0-7 intensity)
*   Bits 4-2: Green component (3 bits, 0-7 intensity)
*   Bits 1-0: Blue component (2 bits, 0-3 intensity)

Example:
*   `%11100000` = Bright Red
*   `%00011100` = Bright Green
*   `%00000011` = Bright Blue
*   `%11111111` = White
*   `%00000000` = Black (This is also the transparent color index for sprites and VRAM tiles)

### Palette Access Registers:
The color palette is accessed indirectly via two special registers:
*   `$0x20810` - `PALETTE_ADDR_REG` (Write-only): Specifies the palette index (0-255) to be written to. Writing to this register sets the target for the next write to the `PALETTE_DATA_REG`. This register auto-increments by 1 after each write to `PALETTE_DATA_REG`, allowing for rapid palette updates.
*   `$0x20811` - `PALETTE_DATA_REG` (Write-only): The 8-bit R3G3B2 color value to be written to the palette index previously selected by `PALETTE_ADDR_REG`.

To modify palette entries:
1.  Write the starting palette index (0-255) to `PALETTE_ADDR_REG` (`$0x20810`).
2.  Write the 8-bit color value to `PALETTE_DATA_REG` (`$0x20811`) for that index.
3.  To write to the next consecutive palette entry, simply write its color value to `PALETTE_DATA_REG` again (due to auto-increment of `PALETTE_ADDR_REG`).
4.  To write to a non-consecutive palette entry, repeat step 1 with the new index.

Reading the palette is not directly supported via these registers; programs must keep a copy of palette data in general RAM if needed. The palette is initialized to a default state by the system on startup/reset (typically a standard "fantasy console" palette including various grays, primary colors, pastels, etc.).

---
## 12. Text Rendering System

The FC-8 provides a tile-based text rendering system for displaying fixed-width text efficiently. This system uses a built-in font and a dedicated character map in memory.

### Built-in Font:
The VM includes a non-modifiable, fixed-width bitmap font stored in its internal ROM.
*   Character Size: 8x8 pixels per character.
*   Character Set: Standard ASCII printable characters, specifically code points 32 (space) through 126 (~). Other character codes (0-31, 127-255) may result in undefined characters or a default glyph (e.g., a solid block or space).

### Text Display Method (Tile-based Text Layer):
The system uses a "Character Map" (also known as a text buffer or screen RAM for text) located in a dedicated portion of the Special Register memory space. The hardware automatically reads this map and renders the specified characters to the screen using the built-in font.

#### Character Map:
*   Location: `$0x21000` - `$0x2177F` (1920 bytes total).
*   Dimensions: The map is organized as 32 columns by 30 rows, corresponding to a 256x240 pixel screen with 8x8 characters.
    (32 chars/row * 30 rows = 960 characters total).
*   Cell Structure: Each character cell in the map consists of 2 bytes:
    *   Byte 0: Character Code (ASCII value, 32-126 recommended).
    *   Byte 1: Attribute Byte.
        *   Bits 0-3 (Foreground Color): Selects a color index from the global 256-color palette. Typically, this would be limited to a subset (e.g., the first 16 colors, `$0`-`$F`) for text to ensure readability and classic aesthetics.
        *   Bits 4-7 (Background Color): Selects a color index from the global 256-color palette for the character's 8x8 cell background. Also typically limited (e.g., first 16 colors, `$0`-`$F`). If Background Color index is `$00` (the system's transparent color index), the VRAM background layer will show through behind the character glyph.
*   Map Layout: The map is linear in memory. Cell (0,0) (top-left) is at `$0x21000`, cell (1,0) is at `$0x21002`, up to cell (31,29) (bottom-right) at `$0x2177E`.
    Address = `$0x21000` + (row * 32 + column) * 2.

### Control Registers:
A dedicated register controls the text layer's visibility and priority.
*   `$0x20840` - `TEXT_CTRL_REG` (Text Control Register) (R/W):
    *   Bit 0: Text Layer Enable (1 = Enabled, 0 = Disabled). When disabled, the text layer is not drawn. Default is 0 (Disabled).
    *   Bit 1: Text Layer Priority (0 = Text layer is drawn behind high-priority sprites, 1 = Text layer is drawn in front of all sprites). Default is 0.
    *   Bits 2-7: Reserved (write as 0).

### Interaction with Other Layers:
*   The text layer, when enabled, is an overlay on the screen.
*   If a text cell's Background Color index is `$00` (transparent), the VRAM background layer will be visible behind the character glyph in that cell. Otherwise, the cell's background color will obscure the VRAM background.
*   Sprites can be drawn over or under the text layer, controlled by the 'Text Layer Priority' bit in `TEXT_CTRL_REG` and the individual sprite's 'Priority' attribute.
    *   If Text Layer Priority is 0: Text is behind high-priority sprites but in front of normal-priority sprites.
    *   If Text Layer Priority is 1: Text is in front of all sprites.
*   The text layer itself is always drawn over the VRAM background layer (unless a cell's background is transparent).

---
## 13. Glossary of Terms
*   `**VM (Virtual Machine):**` A software emulation of a computer system.
*   `**CPU (Central Processing Unit):**` The primary component of a computer that executes instructions.
*   `**VRAM (Video RAM):**` Memory dedicated to storing graphics data for display.
*   `**ISA (Instruction Set Architecture):**` The part of the computer architecture related to programming, including the native data types, instructions, registers, addressing modes, memory architecture, interrupt and exception handling, and external I/O.
*   `**ALU (Arithmetic Logic Unit):**` A digital circuit within the processor that performs arithmetic and bitwise logic operations on integer binary numbers.
*   `**VBLANK (Vertical Blanking Interval):**` The time period between the end of the last line of a frame or field and the beginning of the first line of the next frame or field. During this time, the electron beam of a CRT display returns to the top of the screen.
*   `**PCM (Pulse-Code Modulation):**` A method used to digitally represent sampled analog signals. It is the standard form of digital audio in computers, compact discs, digital telephony and other digital audio applications.
*   `**R3G3B2:**` A color format where 3 bits are used for Red, 3 bits for Green, and 2 bits for Blue, allowing for 256 possible colors (2^3 * 2^3 * 2^2 = 8 * 8 * 4 = 256).

---

## Developing Games via Hex Editor
This section is dedicated to developers who wish to program games for the FC-8 directly using a hex editor. This approach is challenging but offers a deep understanding of the hardware and complete control over the resulting byte code.

### Core Concepts for Hex Editing
*   **Cartridge Structure is Key:** Thoroughly understand Section 4: "Cartridge Format". You will be manually constructing the cartridge header and laying out data for program code, sprites, sound, etc.
*   **CPU Instructions as Bytes:** You will use the Opcode Table (Section 5) to write your program logic. Each instruction and its operands translate directly to a sequence of bytes. Remember the CPU is Little Endian.
*   **Memory Addresses:** All special registers, VRAM, and cartridge data are accessed via their absolute memory addresses as defined in this document.
*   **Asset Management:** Sprite pixel data, sound data, and map data must be formatted exactly as specified and placed at the correct offsets within the cartridge, with the header pointing to them.

### Tools of the Trade
*   **Hex Editor:** A good hex editor is your primary tool (e.g., HxD, Hex Fiend, GHex). It should allow you to easily view and edit bytes, insert/delete bytes, and save raw binary files.
*   **Calculator:** A programmer's calculator for hex/decimal conversions is invaluable.
*   **(Optional) Assembler:** While the goal here is hex editing, a simple cross-assembler that can output raw binary (not an object file format) for the FC-8's ISA can be a significant time-saver for writing the code portion. You would then use the hex editor to combine this code with your manually crafted header and assets.
*   **(Optional) Helper Scripts:** Small scripts (e.g., Python) can help automate tasks like calculating checksums, inserting sprite data, or formatting data sections.

### Example: "Display a Single Sprite" Program (Conceptual)
This is a simplified, conceptual example of how one might structure a minimal cartridge to display one sprite. Addresses are relative to cartridge start (`$0x30000`).

1.  **Cartridge Header (First 256 bytes - `$0000` to `$00FF` relative to cart start):**
    *   `$0000-$0003`: "FC8C" (Magic Number: `46 43 38 43`)
    *   `$0004-$0023`: "My Sprite Test" + padding (Game Title: e.g., `4D 79 20 53 ... 00`)
    *   `$0024-$0025`: `01 00` (Version 1.0)
    *   `$0026-$0027`: `00 01` (Program Entry Point: `$0100` relative to cart, so absolute `$30100`)
    *   `$0028-$0029`: `00 01` (Offset to Program Code: `$0100` relative)
    *   `$002A-$002B`: (Size of program code, e.g., `10 00` for 16 bytes)
    *   `$002C-$002D`: `00 02` (Offset to Sprite Data: `$0200` relative, so absolute `$30200`)
    *   `$002E-$002F`: `00 01` (Size of Sprite Data: 256 bytes for one 16x16 sprite)
    *   Other offsets/sizes (Sound, Map) can be zero if unused.
    *   Fill remaining header bytes up to `$00FF` with `00`.

2.  **Program Code (Starts at `$0100` relative to cart start):**
    This code will set up one sprite in the Sprite Attribute Table.
    *   Target Sprite Entry 0: `$20200`
    *   Sprite ID: `$00` (first sprite in our sprite data)
    *   X-Pos: `$50` (80 decimal)
    *   Y-Pos: `$40` (64 decimal)
    *   Attributes: `$00` (Normal, no flip)

    Hex code sequence (example):
    *   `A9 00`       (LDA #$00 ; Load Sprite ID 0)
    *   `8D 00 20`    (STA $20200 ; Store to Sprite Entry 0, Byte 0 - Sprite ID)
    *   `A9 50`       (LDA #$50 ; Load X-Position)
    *   `8D 01 20`    (STA $20201 ; Store to Sprite Entry 0, Byte 1 - X-Pos)
    *   `A9 40`       (LDA #$40 ; Load Y-Position)
    *   `8D 02 20`    (STA $20202 ; Store to Sprite Entry 0, Byte 2 - Y-Pos)
    *   `A9 00`       (LDA #$00 ; Load Attributes)
    *   `8D 03 20`    (STA $20203 ; Store to Sprite Entry 0, Byte 3 - Attributes)
    *   `A9 01`       (LDA #$01 ; Enable SCREEN_CTRL_REG display)
    *   `8D 00 20`    (STA $20800) ; Write to SCREEN_CTRL_REG (assuming $20800 is its address)
    *   `4C XX YY`    (JMP to self for infinite loop, e.g., `4C 1C 01` if this JMP is at `$011C` relative)

3.  **Sprite Data (Starts at `$0200` relative to cart start):**
    *   256 bytes defining a 16x16 sprite. For example, a simple filled square using color index `$0F`:
        `0F 0F 0F ... (16 times) ... 0F` (repeated for 16 rows).
        The first byte `$30200` is pixel (0,0), `$30201` is (1,0) ... `$3020F` is (15,0), `$30210` is (0,1) etc.

This example would then be saved as a single binary file. When loaded by the FC-8, it would (hopefully) display your sprite. Debugging involves checking memory locations and register values if an emulator or hardware debugger is available, or by writing pixel values to screen as a form of `printf` debugging.

Hex editing is a meticulous process requiring patience and attention to detail. Good luck!

---

## FPGA Implementation Guidance
This section provides considerations for engineers implementing the FC-8 fantasy console on an FPGA (Field-Programmable Gate Array) using a hardware description language like Verilog or VHDL.

### Core Philosophy
The FC-8 is designed to be simple enough for FPGA implementation, reminiscent of 8-bit era consoles. The focus should be on accurately replicating the behavior of the CPU, memory map, and peripheral interactions as defined in this specification.

### CPU Implementation
As noted in Section 5, the FC-8 CPU (including its fetch-decode-execute cycle and instruction timings) will be a significant module. Each instruction is typically a state machine. Careful attention must be paid to flag interactions and register updates.

### Memory System
*   **Memory Resources:**
    *   **Stack RAM (`$0x00000 - $0x0FFFF`, 64KB):** Can be implemented using FPGA Block RAM (BRAM). Access time needs to be fast, ideally single-cycle for the CPU.
    *   **VRAM Background (`$0x10000 - $0x1FFFF`, 64KB):** Also suitable for BRAM. Dual-port BRAM might be beneficial if the video generation circuitry needs to read VRAM simultaneously with CPU writes, though careful timing management can allow single-port BRAM.
    *   **Special Registers range (`$0x20000 - $0x2FFFF`):** This range is not true RAM but a memory-mapped I/O space. Each register or register group will be custom logic. Address decoding logic will route CPU read/write signals to the appropriate hardware module.
    *   **Cartridge ROM (`$0x30000 - $0xFFFFF`, 832KB):** This is the largest memory block.
        *   For smaller FPGAs, this might require external storage like a Flash memory chip, with a memory controller to interface it to the CPU's address bus.
        *   Larger FPGAs might have enough BRAM or on-chip Flash to hold smaller game ROMs directly.
        *   Consider a bootloader mechanism if cartridges are loaded from external media (e.g., SD card) into RAM or a dedicated Cartridge RAM region (if not executing directly from Flash). This spec assumes direct mapping for simplicity.
*   **Memory Access Timing:** The CPU's 5MHz clock dictates memory cycle times. Ensure that memory (BRAM or external) can meet the setup and hold times required by the CPU's bus cycle. Wait states might be needed if accessing slower external memory.

### Video Generation
*   **Pixel Clock:** A separate, faster pixel clock will be needed to drive the video output (e.g., for VGA or HDMI). This clock will be synchronized with the 5MHz system clock. For a 256x240 @ 60Hz display (plus blanking intervals), a pixel clock of around 5-6 MHz is common (e.g., ~25MHz master clock divided down).
*   **Timings (HSYNC, VSYNC, Blanking):** Standard video timings (horizontal sync, vertical sync, front/back porch) for the target display resolution (256x240 or 256x256) must be generated.
*   **Data Fetching:**
    *   VRAM data for the background layer needs to be fetched row by row, pixel by pixel, according to scroll registers and other VRAM control flags.
    *   Sprite data needs to be fetched from the Sprite Attribute Table (in Special Registers) and then the sprite pixel data from Cartridge ROM. This involves iterating through active sprites, checking their X/Y positions against the current scanline, and rendering their pixels (respecting transparency and priority).
    *   Text character codes and attributes are fetched from the Character Map, and glyphs from an internal font ROM (which can be implemented as a ROM block in the FPGA).
*   **Palette:** The 256-entry color palette (R3G3B2) is stored in registers or small BRAM. Fetched color indices are looked up here to get the final R,G,B values for the DAC or digital video output.
*   **Layer Compositing:** The hardware must correctly composite the VRAM background, sprites, and text layer based on transparency and priority rules.

### Audio System
*   Each of the 4 audio channels should be implemented as a separate digital sound generation module.
*   Registers for frequency, volume, waveform, and control will gate and shape the output of oscillators (for square, saw, triangle) or a Linear Feedback Shift Register (LFSR for noise).
*   The outputs of the channels are typically mixed (summed) and then passed through a master volume control.
*   For an FPGA, the final output might be a Pulse Width Modulated (PWM) signal that can be low-pass filtered externally to produce analog audio, or a direct digital audio stream (like I2S if an external DAC is used).

### Input System
*   The Gamepad State Register (`$0x20600`) is implemented as a set of flip-flops that latch the state of physical buttons connected to FPGA pins. Debouncing logic for button inputs is essential.

### Clocking and Reset
*   A master clock input to the FPGA will be divided down to generate the 5MHz system clock for the CPU and peripherals. As mentioned, a separate pixel clock will also be derived.
*   A global reset signal should initialize all CPU registers, special function registers (to their defined default states), and internal state machines.

### General FPGA Design
*   **Modularity:** Design the system with clear modules (CPU, memory controller, VRAM controller, sprite engine, audio channels, etc.) for easier development and debugging.
*   **Address Decoding:** A central address decoder will take the CPU's memory address and generate chip select / enable signals for the various memory regions and special registers.
*   **Testing:** Simulate each module thoroughly before synthesizing to hardware. On-chip logic analyzers (like Xilinx ChipScope or Intel SignalTap) are invaluable for debugging on the actual FPGA.

---
## 14. List Of Special Registers

This section lists memory-mapped special registers used for controlling various hardware features of the FC-8.

`$0x20000` - `$0x200FF` :: **Screen Bounding Bottom Offsets** (R/W)
*   Each byte `$0x20000 + X` specifies the upward vertical offset (0-255) for the bottom display boundary of screen column X. A value of 0 means no offset. See Section 8 'VRAM background Information' for a detailed explanation.

`$0x20100` :: `VRAM_FLAGS_REG` (VRAM Control Flags Register) (R/W)
*   Bit 0: Mirror-X (0=Off, 1=On for VRAM background tiling)
*   Bit 1: Mirror-Y (0=Off, 1=On for VRAM background tiling)
*   Bit 2: Flip-X (0=Off, 1=On for VRAM background tiling - typically applies before mirroring)
*   Bit 3: Flip-Y (0=Off, 1=On for VRAM background tiling - typically applies before mirroring)
*   Bits 4-7: Page Select / Coarse Y Offset (Signed 4-bit value, -8 to +7. Adds (value * 16) to Y scroll.)
(See Section 8 'VRAM background Information' for full details)

`$0x20101` :: `VRAM_SCROLL_X_REG` (VRAM Fine Scroll X Register) (R/W)
*   8-bit value (0-255) for fine horizontal pixel scroll of VRAM background.

`$0x20102` :: `VRAM_SCROLL_Y_REG` (VRAM Fine Scroll Y Register) (R/W)
*   8-bit value (0-255) for fine vertical pixel scroll of VRAM background.
	
`$0x20103` - `$0x201FF` :: **Reserved VRAM Control Space**

`$0x20200` - `$0x205FF` :: **Foreground Sprite Attribute Table (Hardware Sprites)**
*   256 entries, 4 bytes each. Format: `[Sprite ID][X-Pos][Y-Pos][Attribute Flags]`.
(See **Sprite System** section for full details)

`$0x20600` :: `GAMEPAD_STATE_REG` (Gamepad State Register) (Read-only)
*   8-bit register reflecting the current state of gamepad buttons.
(See **Input System** section for details)

`$0x20700` - `$0x20704` :: `CH1_AUDIO_REGS` (Audio Channel 1 Registers) (R/W)
`$0x20705` - `$0x20709` :: `CH2_AUDIO_REGS` (Audio Channel 2 Registers) (R/W)
`$0x2070A` - `$0x2070E` :: `CH3_AUDIO_REGS` (Audio Channel 3 Registers) (R/W)
`$0x2070F` - `$0x20713` :: `CH4_AUDIO_REGS` (Audio Channel 4 Registers) (R/W)
*   Registers: `FreqLo`, `FreqHi`, `Vol/Env`, `Wave/Duty`, `Ctrl`
(See **Audio System** section for detailed breakdown of individual register names and functions within each block)

`$0x207F0` :: `AUDIO_MASTER_VOL_REG` (Audio Master Volume Control) (R/W)
`$0x207F1` :: `AUDIO_SYSTEM_CTRL_REG` (Audio System Enable/Disable Control) (R/W)
(See **Audio System** section for detailed breakdown)

`$0x20800` :: `SCREEN_CTRL_REG` (Screen Control Register) (R/W)
*   Controls master display enable and active resolution mode (256x240 vs 256x256). See Section 6 'Clock, Timing, and Synchronization' under 'Master Display Control' for full details.

`$0x20810` :: `PALETTE_ADDR_REG` (Palette Address Register) (Write-only)
*   Selects palette index (0-255) for `PALETTE_DATA_REG`. Auto-increments.
`$0x20811` :: `PALETTE_DATA_REG` (Palette Data Register) (Write-only)
*   8-bit R3G3B2 color data for selected palette index.
(See **Color Palette System** section for details)

`$0x20820` :: `FRAME_COUNT_LO_REG` (System Frame Counter - Low Byte) (Read-only)
`$0x20821` :: `FRAME_COUNT_HI_REG` (System Frame Counter - High Byte) (Read-only)
*   16-bit counter, increments each frame at VBLANK start.
(See **Clock, Timing, and Synchronization** section for details)

`$0x20830` :: `RAND_NUM_REG` (Random Number Generator Register) (R/W)
*   Reading returns an 8-bit pseudo-random number. Writing any value re-seeds the PRNG. See Section 6 'Clock, Timing, and Synchronization' under 'Random Number Generator' for more details.

`$0x20840` :: `TEXT_CTRL_REG` (Text Control Register) (R/W)
*   Bit 0: Text Layer Enable
*   Bit 1: Text Layer Priority.
(See **Text Rendering System** section for details)

`$0x20850` :: `VSYNC_STATUS_REG` (VSync Status Register) (Read-only, bit 1 clears on read)
*   Bit 0: `IN_VBLANK` status
*   Bit 1: `NEW_FRAME` latch.
(See **Clock, Timing, and Synchronization** section for details)

`$0x21000` - `$0x2177F` :: **Text Character Map** (32x30 cells, 2 bytes/cell) (R/W)
*   Stores character codes and attributes for the tile-based text layer.
(See **Text Rendering System** section for details)

---
## 15. License
This work is licensed under the Creative Commons Attribution-ShareAlike 4.0 International License. To view a copy of this license, visit [http://creativecommons.org/licenses/by-sa/4.0/](http://creativecommons.org/licenses/by-sa/4.0/) or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.
